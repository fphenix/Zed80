#  opcode    instr    M-cycles Tcycles Rcycles   byte-param     operation-to-evaluate    comment

###############################################################
#
#  8-Bit Load Group
#
###############################################################


#--------------------------------------------------------------
# LD pt,ps
# 1101 1101 01tttsss
foreach t [array names RegCode_p] {
  foreach s [array names RegCode_p] {
    set byte [bin2hex 11011101][string range [bin2hex 01[set RegCode_p($t)][set RegCode_p($s)]] 2 end]
    append CmdLst " $byte"
    append CmdLst " {LD $t,$s}"
    append CmdLst " 2 8 2 0"
    if {[string equal $s {IXh}]} {
      set sour {[Reg8 IX h]}
    } elseif {[string equal $s {IXl}]} {
      set sour {[Reg8 IX l]}
    } else {
      set sour {$Reg(}
      append sour $s
      append sour {)}
    }
    if {[string equal $t {IXh}]} {
      set dest {Reg(IX) [doReg16 }
      append dest $sour
      append dest { [Reg8 IX l]]}
    } elseif {[string equal $t {IXl}]} {
      set dest {Reg(IX) [doReg16 [Reg8 IX h] }
      append dest $sour
      append dest {]}
    } else {
      set dest "Reg($t) "
      append dest $sour
    }
    append CmdLst " {set $dest ; set TEMP(8L) $sour}"
    append CmdLst " {$t = $s = \$TEMP(8L)}\n"
  }
}

#--------------------------------------------------------------
# LD qt,qs
# 11111101 01tttsss
foreach t [array names RegCode_q] {
  foreach s [array names RegCode_q] {
    set byte [bin2hex 11111101][string range [bin2hex 01[set RegCode_q($t)][set RegCode_q($s)]] 2 end]
    append CmdLst " $byte"
    append CmdLst " {LD $t,$s}"
    append CmdLst " 2 8 2 0"
    if {[string equal $s {IYh}]} {
      set sour {[Reg8 IY h]}
    } elseif {[string equal $s {IYl}]} {
      set sour {[Reg8 IY l]}
    } else {
      set sour {$Reg(}
      append sour $s
      append sour {)}
    }
    if {[string equal $t {IYh}]} {
      set dest {Reg(IY) [doReg16 }
      append dest $sour
      append dest { [Reg8 IY l]]}
    } elseif {[string equal $t {IYl}]} {
      set dest {Reg(IY) [doReg16 [Reg8 IY h] }
      append dest $sour
      append dest {]}
    } else {
      set dest "Reg($t) "
      append dest $sour
    }
    append CmdLst " {set $dest ; set TEMP(8L) $sour}"
    append CmdLst " {$t = $s = \$TEMP(8L)}\n"
  }
}

   // Resident System eXtension



#--------------------------------------------------------------
# LD p,n
# 11011101 00ppp110 nnnnnnnn
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 00[set RegCode_p($p)]110] 2 end]
  append CmdLst " $byte"
  append CmdLst " {LD $p,\$DATA(0)}"
  append CmdLst " 3 11 2 1"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(IX) \[doReg16 \$DATA(0) \[Reg8 IX l\]\]}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(IX) \[doReg16 \[Reg8 IX h\] \$DATA(0)\]}"
  } else {
    append CmdLst " {set Reg($p) \$DATA(0)}"
  }
  append CmdLst " {$p = \$DATA(0)}\n"
}

#--------------------------------------------------------------
# LD q,n
# 11111101 00ppp110 nnnnnnnn
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 00[set RegCode_q($q)]110] 2 end]
  append CmdLst " $byte"
  append CmdLst " {LD $q,\$DATA(0)}"
  append CmdLst " 3 11 2 1"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(IY) \[doReg16 \$DATA(0) \[Reg8 IY l\]\]}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(IY) \[doReg16 \[Reg8 IY h\] \$DATA(0)\]}"
  } else {
    append CmdLst " {set Reg($q) \$DATA(0)}"
  }
  append CmdLst " {$q = \$DATA(0)}\n"
}

###############################################################
#
# 8-Bit Arithmetic and Logical Group
#
###############################################################


#--------------------------------------------------------------
# ADD A,p
# 11011101 10000ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10000[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {ADD A,$p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IX h\] \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IX l\] \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_plus \$Reg($p) \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {A=A+$p = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# ADD A,q
# 11111101 10000qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10000[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {ADD A,$q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IY h\] \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IY l\] \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_plus \$Reg($q) \$Reg(A)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {A=A+$q = \$Reg(A)}\n"
}


#--------------------------------------------------------------
# ADC A,p
# 11011101 10001ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10001[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {ADC A,$p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IX h\] \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IX l\] \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_plus \$Reg($p) \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {A=A+$p+Carry = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# ADC A,q
# 11111101 10001qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10001[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {ADD A,$q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IY h\] \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[Reg8_plus \[Reg8 IY l\] \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_plus \$Reg($q) \$Reg(A) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {A=A+$q+Carry = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# SUB p
# 11011101 10010ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10010[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {SUB $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IX h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IX l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \$Reg($p)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {A=A-$p = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# SUB q
# 11111101 10010qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10010[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {SUB $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IY h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IY l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \$Reg($q)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {A=A-$q = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# SBC A,p
# 11011101 10011ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10011[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {SBC A,$p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IX h\] \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IX l\] \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \$Reg($p) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {A=A-$p-Carry = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# SBC A,q
# 11111101 10011qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10011[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {SBC A,$q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IY h\] \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \[Reg8 IY l\] \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set Reg(A) \[Reg8_minus \$Reg(A) \$Reg($q) \$Flag(C)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] \[Bit A 4\] \[Bit A 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {A=A-$q-Carry = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# AND p
# 11011101 10100ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10100[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {AND $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \[Reg8 IX h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \[Reg8 IX l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \$Reg($p)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A AND $p = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# AND q
# 11111101 10100qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10100[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {AND $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \[Reg8 IY h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \[Reg8 IY l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) & \$Reg($q)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 1 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A AND $q = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# OR p
# 11011101 10110ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10110[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {OR $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \[Reg8 IX h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \[Reg8 IX l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \$Reg($p)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A OR $p = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# OR q
# 11111101 10110qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10110[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {OR $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \[Reg8 IY h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \[Reg8 IY l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) | \$Reg($q)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A OR $q = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# XOR p
# 11011101 10101ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10101[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {XOR $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \[Reg8 IX h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \[Reg8 IX l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \$Reg($p)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A XOR $p = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# XOR q
# 11111101 10101qqq
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10101[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {XOR $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \[Reg8 IY h\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \[Reg8 IY l\]\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  } else {
    append CmdLst " {set Reg(A) \[expr \$Reg(A) ^ \$Reg($q)\] ; SetFlag \[Bit A 7\] \[isZero A\] \[Bit A 5\] 0 \[Bit A 3\] \[inv \[Bit A 0\]\] 0 0}"
  }
  append CmdLst " {A = A XOR $q = \$Reg(A)}\n"
}

#--------------------------------------------------------------
# CP p
# 11011101 10111ppp
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 10111[set RegCode_p($p)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {CP $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IX h\] ; set TEMP(8L) \[Reg8_minus \$Reg(A) \[Reg8 IX h\]\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \[Reg8 IX h\] 5\] \[Bit \$TEMP(8L) 4\] \[Bit \[Reg8 IX h\] 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IX l\] ; set TEMP(8L) \[Reg8_minus \$Reg(A) \[Reg8 IX l\]\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \[Reg8 IX l\] 5\] \[Bit \$TEMP(8L) 4\] \[Bit \[Reg8 IX l\] 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set TEMP(8H) \$Reg8($p) ; set TEMP(8L) \[Reg8_minus \$Reg(A) \$Reg($p)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$Reg($p) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$Reg($p) 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {Compare A and $p ; A = \$Reg(A) ; $p = \TEMP(8H)}\n"
}

#--------------------------------------------------------------
# CP q
# 11111101 10111ppp
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 10111[set RegCode_q($q)]] 2 end]
  append CmdLst " $byte"
  append CmdLst " {CP $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IY h\] ; set TEMP(8L) \[Reg8_minus \$Reg(A) \[Reg8 IY h\]\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \[Reg8 IY h\] 5\] \[Bit \$TEMP(8L) 4\] \[Bit \[Reg8 IY h\] 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IY l\] ; set TEMP(8L) \[Reg8_minus \$Reg(A) \[Reg8 IY l\]\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \[Reg8 IY l\] 5\] \[Bit \$TEMP(8L) 4\] \[Bit \[Reg8 IY l\] 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  } else {
    append CmdLst " {set TEMP(8H) \$Reg8($q) ; set TEMP(8L) \[Reg8_minus \$Reg(A) \$Reg($q)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$Reg($q) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$Reg($q) 3\] \$TEMP(OV) 1 \$TEMP(C)}"
  }
  append CmdLst " {Compare A and $q ; A = \$Reg(A) ; $q = \TEMP(8H)}\n"
}

#--------------------------------------------------------------

#--------------------------------------------------------------
# INC p
# 11011101 00ppp100
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 00[set RegCode_p($p)]100] 2 end]
  append CmdLst " $byte"
  append CmdLst " {INC $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8_plus \[Reg8 IX h\]\] ; set TEMP(8L) \[Reg8 IX l\] ; set Reg(IX) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8H) 7\] \[isZero \$TEMP(8H)\] \[Bit \$TEMP(8H) 5\] \[Bit \$TEMP(8H) 4\] \[Bit \$TEMP(8H) 3\] \$TEMP(OV) 0 x}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IX h\] ; set TEMP(8L) \[Reg8_plus \[Reg8 IX l\]\] ; set Reg(IX) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$TEMP(8L) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$TEMP(8L) 3\] \$TEMP(OV) 0 x}"
  } else {
    append CmdLst " {set Reg($p) \[Reg8_plus \$Reg($p)\] ; SetFlag \[Bit $p 7\] \[isZero $p\] \[Bit $p 5\] \[Bit $p 4\] \[Bit $p 3\] \$TEMP(OV) 0 x}"
  }
  append CmdLst " {$p = $p + 1 = \$Reg($p)}\n"
}

#--------------------------------------------------------------
# INC q
# 11111101 00qqq100
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 00[set RegCode_q($q)]100] 2 end]
  append CmdLst " $byte"
  append CmdLst " {INC $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8_plus \[Reg8 IY h\]\] ; set TEMP(8L) \[Reg8 IY l\] ; set Reg(IY) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8H) 7\] \[isZero \$TEMP(8H)\] \[Bit \$TEMP(8H) 5\] \[Bit \$TEMP(8H) 4\] \[Bit \$TEMP(8H) 3\] \$TEMP(OV) 0 x}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IY h\] ; set TEMP(8L) \[Reg8_plus \[Reg8 IY l\]\] ; set Reg(IY) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$TEMP(8L) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$TEMP(8L) 3\] \$TEMP(OV) 0 x}"
  } else {
    append CmdLst " {set Reg($q) \[Reg8_plus \$Reg($q)\] ; SetFlag \[Bit $q 7\] \[isZero $q\] \[Bit $q 5\] \[Bit $q 4\] \[Bit $q 3\] \$TEMP(OV) 0 x}"
  }
  append CmdLst " {$q = $q + 1 = \$Reg($q)}\n"
}

#--------------------------------------------------------------
# DEC p
# 11011101 00ppp101
foreach p [array names RegCode_p] {
  set byte [bin2hex 11011101][string range [bin2hex 00[set RegCode_p($p)]101] 2 end]
  append CmdLst " $byte"
  append CmdLst " {DEC $p}"
  append CmdLst " 2 8 2 0"
  if {[string equal $p {IXh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8_minus \[Reg8 IX h\]\] ; set TEMP(8L) \[Reg8 IX l\] ; set Reg(IX) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8H) 7\] \[isZero \$TEMP(8H)\] \[Bit \$TEMP(8H) 5\] \[Bit \$TEMP(8H) 4\] \[Bit \$TEMP(8H) 3\] \$TEMP(OV) 1 x}"
  } elseif {[string equal $p {IXl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IX h\] ; set TEMP(8L) \[Reg8_minus \[Reg8 IX l\]\] ; set Reg(IX) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$TEMP(8L) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$TEMP(8L) 3\] \$TEMP(OV) 1 x}"
  } else {
    append CmdLst " {set Reg($p) \[Reg8_minus \$Reg($p)\] ; SetFlag \[Bit $p 7\] \[isZero $p\] \[Bit $p 5\] \[Bit $p 4\] \[Bit $p 3\] \$TEMP(OV) 1 x}"
  }
  append CmdLst " {$p = $p - 1 = \$Reg($p)}\n"
}

#--------------------------------------------------------------
# DEC q
# 11111101 00qqq101
foreach q [array names RegCode_q] {
  set byte [bin2hex 11111101][string range [bin2hex 00[set RegCode_q($q)]101] 2 end]
  append CmdLst " $byte"
  append CmdLst " {DEC $q}"
  append CmdLst " 2 8 2 0"
  if {[string equal $q {IYh}]} {
    append CmdLst " {set TEMP(8H) \[Reg8_minus \[Reg8 IY h\]\] ; set TEMP(8L) \[Reg8 IY l\] ; set Reg(IY) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8H) 7\] \[isZero \$TEMP(8H)\] \[Bit \$TEMP(8H) 5\] \[Bit \$TEMP(8H) 4\] \[Bit \$TEMP(8H) 3\] \$TEMP(OV) 1 x}"
  } elseif {[string equal $q {IYl}]} {
    append CmdLst " {set TEMP(8H) \[Reg8 IY h\] ; set TEMP(8L) \[Reg8_minus \[Reg8 IY l\]\] ; set Reg(IY) \[Reg16 \$TEMP(8H) \$TEMP(8L)\] ; SetFlag \[Bit \$TEMP(8L) 7\] \[isZero \$TEMP(8L)\] \[Bit \$TEMP(8L) 5\] \[Bit \$TEMP(8L) 4\] \[Bit \$TEMP(8L) 3\] \$TEMP(OV) 1 x}"
  } else {
    append CmdLst " {set Reg($q) \[Reg8_minus \$Reg($q)\] ; SetFlag \[Bit $q 7\] \[isZero $q\] \[Bit $q 5\] \[Bit $q 4\] \[Bit $q 3\] \$TEMP(OV) 1 x}"
  }
  append CmdLst " {$q = $q - 1 = \$Reg($q)}\n"
}


###############################################################
#
# Input and Output Group
#
###############################################################

# NOTE: These instructions are sometimes weird to use, especially
# when the z80 is the heart of the Amstrad CPC.
# For instance on CPC the peripherals are in fact wired to the
# Higher byte of the Address bus.
# Hence when you write:
#   OUT (C),A
# It will in fact send the value in the Accumulator on the address
# pointed by the register B (Higher byte of BC), even though B is
# not explicitely given in the instruction.
#
# For that same reason the INI command is buggy on CPC, because
# B would represent both the address of the peripheric and the
# counter, which is not possible.

###############################################################


#--------------------------------------------------------------
# INI
# 11101101 10100010

#--------------------------------------------------------------
# INIR
# 11101101 10110010

#--------------------------------------------------------------
# IND
# 11101101 10101010

#--------------------------------------------------------------
# INDR
# 11101101 10111010

#--------------------------------------------------------------
# OUTI
# 11101101 10100010

#--------------------------------------------------------------
# OTIR
# 11101101 10110010

#--------------------------------------------------------------
# OUTD
# 11101101 10101010

#--------------------------------------------------------------
# OTDR
# 11101101 10111010

###############################################################
#
# 16-Bit Artithmetic Group
#
###############################################################

#--------------------------------------------------------------
# ADC HL,ss
# 11101101 01ss1010
foreach d [array names RegCode_d] {
  set byte [bin2hex 11101101][string range [bin2hex 01[set RegCode_d($d)]1010] 2 end]
  foreach {d1 d2} [split $d {}] {break}
  append CmdLst " $byte"
  append CmdLst " {ADC HL,$d}"
  append CmdLst " 4 15 2 0"
  if {[string equal $d "SP"]} {
    append CmdLst " {Reg16_plus \[Reg16 H L\] \$Reg($d) \$Flag(C) ; set Reg(H) \$TEMP(8A) ; set Reg(L) \$TEMP(8B) ; SetFlag \[Bit \$Reg(H) 7\] \[expr \[isZero \$Reg(H)\] & \[isZero \$Reg(L)\]\] \[Bit \$Reg(H) 5\] \[Bit \$Reg(H) 4\] \[Bit \$Reg(H) 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {Reg16_plus \[Reg16 H L\] \[Reg16 $d1 $d2\] \$Flag(C) ; set Reg(H) \$TEMP(8A) ; set Reg(L) \$TEMP(8B) ; SetFlag \[Bit \$Reg(H) 7\]  \[expr \[isZero \$Reg(H)\] & \[isZero \$Reg(L)\]\] \[Bit \$Reg(H) 5\] \[Bit \$Reg(H) 4\] \[Bit \$Reg(H) 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {HL = HL+$d +carry = \[Reg16 H L\]}\n"
}

#--------------------------------------------------------------
# SBC HL,ss
# 11101101 01ss0010
foreach d [array names RegCode_d] {
  set byte [bin2hex 11101101][string range [bin2hex 01[set RegCode_d($d)]0010] 2 end]
  foreach {d1 d2} [split $d {}] {break}
  append CmdLst " $byte"
  append CmdLst " {SBC HL,$d}"
  append CmdLst " 4 15 2 0"
  if {[string equal $d "SP"]} {
    append CmdLst " {Reg16_minus \[Reg16 H L\] \$Reg($d) \$Flag(C) ; set Reg(H) \$TEMP(8A) ; set Reg(L) \$TEMP(8B) ; SetFlag \[Bit \$Reg(H) 7\] \[expr \[isZero \$Reg(H)\] & \[isZero \$Reg(L)\]\] \[Bit \$Reg(H) 5\] \[Bit \$Reg(H) 4\] \[Bit \$Reg(H) 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  } else {
    append CmdLst " {Reg16_minus \[Reg16 H L\] \[Reg16 $d1 $d2\] \$Flag(C) ; set Reg(H) \$TEMP(8A) ; set Reg(L) \$TEMP(8B) ; SetFlag \[Bit \$Reg(H) 7\]  \[expr \[isZero \$Reg(H)\] & \[isZero \$Reg(L)\]\] \[Bit \$Reg(H) 5\] \[Bit \$Reg(H) 4\] \[Bit \$Reg(H) 3\] \$TEMP(OV) 0 \$TEMP(C)}"
  }
  append CmdLst " {HL = HL-$d-carry = \[Reg16 H L\]}\n"
}

